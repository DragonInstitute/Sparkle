# Sparkle

一个渐进式的依赖数据库管理工具。

已经有很多包的源代码托管在 GitHub 上，那么，我们只需要一个数据库来管理这些包，这样就有一个简单的包管理器可以使用了。

既然包本身就托管在 GitHub 上，那为什么数据库不可以？Sparkle 的设计目标便是一个依赖数据库管理工具，而不那么关心数据来源——可以加载不同的插件从而从不同的源获取包。

出于方便考虑，所以下面的说明暂时以 Go 的包管理，源代码托管在 GitHub 上为例。但请注意，Sparkle 的设计目标并不是仅仅支持 Go。

目前版本的 README 只是一些对 feature 的零碎想法的集合，用语措辞都不太严肃，还在修订中。细节的缺失是不可避免的。

# 包的镜像

Sparkle 需要支持同一个包的不同镜像。对于镜像来说，他们的内容应当完全相同，也就是可以任意替代，不应出现版本不同步现象。

# 下载模块

对于下载来说，应当支持不同的下载插件。例如，初版甚至可以直接调用 Git、curl、Wget 等下载工具，但也应当允许支持其他的下载方式。

需要注意的是，下载到哪里也是一个需要被考虑的问题，也应当是一个可以自定义的。

考虑一个场景：

用户 User 的一个叫做 Example 的项目/包 在 Bitbucket 和 GitHub 上都有，并且他们是完全相同的。那么下载到的地址应当是 bitbucket.org/user/example 还是 github.com/user/example 呢？对于使用者来说，可能实际上下载到 /user/example 是更好的选择。但是，我们要注意，同一个 /user/example 下，Bitbucket 和 GitHub 里的内容可能不完全一样。但又由于 Go 的机制，一长串的 github.com/xxx/yyy 是不友好的。实际上，用户根本不在乎包是从哪里下载下来，用户需要关心的只是他们需要一个叫做 Example 的包而已。

考虑第二个场景：

仓库 A 和 B 由两个不同的组织维护，他们中可能会存在命名上的冲突。如何管理其冲突，又不影响到具体的使用，是一个问题。


我个人的观点倾向是，下载和使用可以处于不同的位置。我们可以将包下载到一长串目录底下，但是可以在使用时放到一个相对干净的位置。具体的实现和规定上，还待讨论。

# 多语言支持

Sparkle 不是为 Go 而生的管理器，应当考虑到其他语言的支持。

# 版本

对于包的版本来说，使用者和作者是两个方面。

对于作者而言，提倡语义化的版本号，但具体的版本号怎么写取决于作者自己的观点。

对于用户，大多数时候对包的具体版本不关心。一般而言，会有三种使用场景：

- 锁定版本，绝不自动更新。

- 自动更新，但不应该引入 break change。

- 强制更新到指定版本，或最新。

引入两个名词，软更新（Soft update）和硬更新（Hard update）。

软更新指的是不存在 break change：新增接口，无外部影响的内部行为变更等。

硬更新指的是 break change，也可以指代后续更新可能引入 break change：删除接口，大版本号更新等。

对于包发布者来说，他们可以手动指定一个更新是软更新还是硬更新（出于安全性考虑，不指定则为硬更新）。

对于使用者来说，软更新是安全的，可以随意更新。

## Fallback

对于一个设计目标是“渐进式”的依赖管理数据库来说，我们并不期望所有的包在我们的数据库里，因此我们有必要建立一套版本的 fallback 方案。

请注意，fallback 方案是“插件”的形式。初版可能只支持 Git 的 fallback，但在后续中，可以添加对 SVN 甚至无版本控制的 fallback 支持。

### 版本控制下的 fallback

对于有版本控制的包，例如 Git，那么 Git Tag 会是一个版本数据的 fallback。倘若连 Git Tag 也没有，那么最坏的就是使用 Commit hash 当做版本号了。

# 私有

对于一个依赖数据库来说，私有依赖是必须支持的。考虑到我们的数据库从一开始就不是完整的（所谓“渐进式”），最坏情况下也只是使用用户的私钥去试图访问 GitHub、Bitbucket 等网站，这似乎并不是一个问题。但出于性能上的考虑，我们也得支持用户添加自己的私有包。这不是一个少数场景。

Sparkle 是一个支持多仓库的数据库。用户可以自己建立一套私有的数据库，然后添加到仓库列表里。

# 多仓库支持

Sparkle 应当支持检索多个依赖数据库。

# 额外源与镜像源

Sparkle 并不打算完全依赖于 GitHub 来托管源代码。用户可以建立自己的源，镜像源的建立也是支持的。

由于 Sparkle 从一开始就不是作为一个完整的依赖数据库设计，所以支持额外的源是必须的。注意，这些支持也是插件化的，取得托管在 GitHub 上的代码和托管在 Bitbucket 上的代码流程可能类似，但取得托管在某台个人云服务器上的代码可能就不那么一样。

对于镜像源来说，我们只能镜像存储在我们的数据库里的相关包。倘若真的有计划做一个脱离于 GitHub 的镜像源，那么我们也无需存储海量的 Git log，只需要存储必要的文件就可以了。这部分的转换可以通过一个插件实现。

# 依赖建立

对于一个包或者项目而言（没有本质区别），他的依赖可以按照如下流程建立：

- 扫描所有 import，获得依赖的所有包

- 如果某个包的对应版本在已有的数据库中有记录，其依赖从数据库中取得，并信任此依赖完整（除非指定 flag）。注意，如果你指定的版本是 Latest 而恰好数据库记录了一个旧版本，那么这个旧版本会被当做是最新版而被使用。规避方法是指定一个 flag。

- 如果在数据库中没有记录，从包的源获取，如果源上有其他包管理器存储的依赖信息，那么取得这些信息，并信任此依赖信息完整（除非指定 flag）

- 如果均没有，那么取得完整的源代码，对这个包的源代码重复上述步骤

对于一个扫描过的包，如果 license 允许，我们可能是可以直接添加到我们的公开数据库中的。

当然，最好的情况还是包作者往我们的数据库提交。

# 兼容其他包管理器

这个是显然的。
